\section{Systemübersicht und Datenmodel}

\subsection{Systemübersicht}

Für die Erstellung des Systems wurden im Vorfeld die folgenden Anwendungsfälle (Usecases) 
identifiziert und in einem Usecase-Diagramm dokumentiert.\newline


\noindent Es wurde bewusst entschieden, lediglich eine Benutzerrolle zu implementieren, um den 
Verwaltungsaufwand für den Betrieb des Systems möglichst gering zu halten. Da es sich um ein 
kollaboratives Quizsystem handelt, haben alle Benutzer die Möglichkeit, gemeinsam Fragen zu 
erstellen und zu bearbeiten.\newline

\noindent Im folgenden werden die identifizierten Usecases beschrieben.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/Quiz System - Use Case Diagramm.png}
  \caption{Usecase Diagramm}
\end{figure}

\input{usecase}

\subsection{Projektaufbau \& Frameworks}

Unser Projekt besteht aus zwei wesentlichen Komponenten: dem Frontend und dem Backend.\newline

\noindent Das Frontend ist die Schnittstelle, die auf der Client-Seite im Webbrowser ausgeführt wird.
Diese Komponente ist für die Darstellung der Benutzeroberfläche verantwortlich. 
Sie ermöglicht den Benutzern die Interaktion mit dem System, das Einsehen von Inhalten, das 
Durchführen von Aktionen und das Erleben einer reibungslosen Nutzererfahrung. 
Das Frontend bildet die sichtbare und benutzerfreundliche Oberfläche, die es den Benutzern 
ermöglicht, mit dem System zu interagieren.\newline

\noindent Das Backend hingegen operiert auf der Server-Seite und übernimmt Aufgaben im Hintergrund. 
Hier findet die Verarbeitung von Daten, die Verwaltung von Benutzerkonten, die Interaktion mit der 
Datenbank und die Bereitstellung von Informationen für das Frontend statt. 
Das Backend fungiert als das 'Gehirn' des Systems und ermöglicht die reibungslose Ausführung 
aller Systemfunktionen.\newline

\noindent Eine wichtige Unterscheidung zwischen Frontend und Backend ist die Art der Ausführung. 
Während das Frontend clientseitig im Browser des Benutzers läuft, wird das Backend serverseitig 
betrieben. Diese Trennung ermöglicht eine effiziente Aufgabenteilung und sorgt dafür, 
dass die Anforderungen der Benutzer effektiv verarbeitet werden.\newline

\noindent Die Entscheidung, Frontend und Backend getrennt voneinander zu entwickeln, 
wurde bewusst getroffen und bringt mehrere Vorteile mit sich:

\begin{itemize}
  \item \textbf{Unabhängige Entwicklung:} Die beiden Komponenten können unabhängig voneinander 
  entwickelt werden. Dies ermöglicht es, unterschiedliche Teams oder Entwickler für das Frontend 
  und das Backend einzusetzen, was die Effizienz der Entwicklung steigern kann.
  \item \textbf{Unabhängige Tests:} Die beiden Komponenten können unabhängig voneinander getestet 
  werden. Dadurch können Fehler und Probleme frühzeitig erkannt und behoben werden, ohne die 
  gesamte Anwendung zu beeinträchtigen.
  \item \textbf{Unabhängige Bereitstellung (Deployment):} Frontend und Backend können unabhängig 
  voneinander bereitgestellt werden. Updates oder Änderungen in einer Komponente erfordern 
  nicht zwangsläufig, dass die andere ebenfalls angepasst werden muss.
  \item \textbf{Skalierbarkeit:} Jede Komponente kann unabhängig voneinander skaliert werden, 
  um den Anforderungen des Systems und der Benutzer gerecht zu werden. Dies ermöglicht eine 
  effiziente Ressourcennutzung.
\end{itemize}

\noindent Für die Implementierung des Frontends haben wir uns für das Angular-Framework entschieden.
Angular ist ein leistungsstarkes JavaScript-Framework, das die Entwicklung von anspruchsvollen 
Webanwendungen erleichtert. Es bietet eine breite Palette von Tools und Bibliotheken, 
die es Entwicklern ermöglichen, eine benutzerfreundliche Benutzeroberfläche zu erstellen. \newline

\noindent Das Backend wurde mithilfe des ASP.NET Frameworks realisiert. 
ASP.NET ist ein Framework, das sich besonders für die Entwicklung serverseitiger Anwendungen eignet. 
Es bietet eine Vielzahl von Erweiterungen und Tools, die sich hervorragend für die Implementierung 
einer robusten Web-API eignen.\newline

\noindent Als Datenbank haben wir uns für PostgreSQL entschieden. 
PostgreSQL ist eine Open-Source-relationale Datenbank, die im Vergleich zu MySQL den Vorteil bietet, 
keine Lizenzprobleme zu verursachen. Sie ermöglicht die effiziente Speicherung und Verwaltung von 
Daten, die in der Anwendung benötigt werden.\newline

\noindent Die Kommunikation zwischen Frontend und Backend wurde über eine REST-API realisiert. 
Eine REST-API definiert klare Strukturen für die API-Endpunkte, was die Kommunikation zwischen 
den beiden Komponenten vereinfacht. Über diese API-Schnittstelle können Anwendungen Anfragen an 
das Backend senden und Informationen austauschen. Dies ermöglicht eine nahtlose Integration 
von Frontend und Backend.\newline

\noindent Eine bemerkenswerte Stärke dieser Architektur besteht darin, dass sie eine spätere 
Entwicklung einer mobilen App ermöglicht, die die gleichen Funktionalitäten wie die 
Webanwendung bietet, ohne dass Änderungen am Backend-Code erforderlich sind. 
Dies bietet eine flexible Grundlage für die Erweiterung und Weiterentwicklung des Systems.\newline

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/API Kommunikation.png}
  \caption{API Kommunikation}
\end{figure}

\subsection{Datenmodelle}

Die Anwendung enthält 4 verschiedene Datenmodelle die im folgenden beschrieben werden:

\begin{itemize}
  \item \textbf{Frontend Datenmodel:} ie Frontend-Modelle sind Datenmodelle, die ausschließlich im Frontend-Bereich der 
  Anwendung Verwendung finden. Abhängig von der Gestaltung des Frontends können diese Modelle von den API-Modellen abweichen. 
  In solchen Fällen erfolgt die Zuordnung der API-Modelle zu den Frontend-Modellen durch Mapping-Prozesse.
  \item \textbf{Rest-API Datenmodel / DTO Modelle:} REST-API-Modelle, die auch als DTO-Modelle bezeichnet werden, sind Datenmodelle, 
  die im Backend-Bereich der Anwendung Anwendung finden. Sie dienen zur Definition der Schnittstellen der API und werden von der API an 
  das Frontend gesendet. Im Backend-Bereich werden die DTO-Modelle in die Backend-Modelle überführt (gemappt).
  \item \textbf{Backend Modelle:} Backend-Modelle sind Datenmodelle, die ausschließlich im Backend-Bereich der Anwendung Verwendung finden. 
  Sie sind darauf ausgerichtet, die bereitgestellten Funktionen effizient auszuführen. Im Backend-Bereich werden die Backend-Modelle 
  entweder in die Datenbankmodelle überführt (gemappt) oder in die DTO-Modelle überführt (gemappt).
  \item \textbf{Datenbank Modelle:} Datenbank-Modelle sind spezielle Datenmodelle, die ausschließlich im Kontext der Datenbankverwaltung 
  in der Anwendung Verwendung finden. Ihr Hauptzweck besteht darin, Daten effizient zu speichern und zu verwalten. 
  Im Datenbank-Bereich werden diese Datenbank-Modelle vom Backend gelesen und in die Backend-Modelle überführt (gemappt).

  In diesem Projekt nutzen wir das Entity Framework, welches die Datenbank-Modelle automatisch aus den Backend-Modellen generiert. 
  Ebenso erfolgt die automatische Überführung der Datenbank-Modelle in die Backend-Modelle (Mapping). 
  Darüber hinaus ist für das Entity Framework ein sogenannter Lazy Loading Proxy installiert, der Subproperties automatisch dann 
  lädt, wenn sie benötigt werden.
\end{itemize}


\noindent Besondere Aufmerksamkeit verdient die Betrachtung der API-Modelle und Datenbankmodelle, da diese häufig eine gemeinsame Struktur
 mit den Frontend-Modellen aufweisen. Dies geschieht in der Regel, da das Entity Framework die Datenbankmodelle automatisch aus
den Backend-Modellen generiert. \newline

\noindent Im Folgenden werden wir näher auf die Hintergrund-Modelle (Backend Modelle), die API-Modelle und die Datenbankmodelle eingehen:

\subsubsection{Backend Modelle}

Die Backend-Modelle sind die Datenmodelle, die speziell für die Verarbeitung im Backend der Anwendung verwendet werden. 
Sie sind darauf ausgerichtet, die bereitgestellten Funktionen effizient auszuführen und den Prozess möglichst einfach und 
eindeutig abzubilden. In der folgenden Abbiildung werden die Backend-Modelle in einem UML-Diagramm dargestellt.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/UML-Klasse.png}
  \caption{UML Diagramm der Backend Modelle}
\end{figure}

\noindent Die Backend-Modelle aus dem UML-Diagramm werden im Folgenden näher erläutert:\newline

\noindent\textbf{'ApplicationUser' Klasse:} Im Zentrum der Applikationsmodelle steht die Klasse 'ApplicationUser', die den Benutzer der Anwendung repräsentiert. 
Diese Klasse erbt von der 'IdentityUser' Klasse, die vom ASP.NET Identity Framework bereitgestellt wird. Der ASP.NET Identity Framework 
bietet Funktionen zur Benutzerverwaltung, einschließlich des Anmelde- und Registrierungsprozesses. Darüber hinaus ermöglicht er die 
Verwaltung von Rollen und Ansprüchen (Claims), obwohl diese Funktionen in dieser Applikation nicht genutzt werden. \newline

\noindent\textbf{'Team' Klasse:} Die 'Team'-Klasse repräsentiert ein Team, das von einem Benutzer erstellt werden kann. 
Ein Team kann mehrere Mitglieder haben, und es ist mit dem Quiz-Versuch des Benutzers verknüpft, sofern dieser Mitglied des Teams ist. 
Auf dieser Grundlage kann der Team-Score berechnet werden. \newline

\noindent\textbf{'Quiz' Klasse:} Die 'Quiz'-Klasse repräsentiert ein Quiz, das von einem Benutzer erstellt werden kann. 
Ein Quiz kann mehrere Fragen haben, die in der 'Question'-Klasse abgebildet sind. Zudem ist das Quiz mit dem Quiz-Versuch des Benutzers 
verknüpft, sofern dieser das Quiz erstellt hat. \newline

\noindent\textbf{'Question' Klasse:} Die 'Question'-Klasse repräsentiert eine Frage, die zu einem Quiz gehört. 
Eine Frage kann mehrere Antworten haben, die in der 'Answer'-Klasse abgebildet werden. Zudem ist die Frage mit dem Quiz-Versuch des 
Benutzers verknüpft, sofern dieser die Frage erstellt hat. \newline

\noindent\textbf{'Answer' Klasse:} Die 'Answer'-Klasse repräsentiert eine Antwort, die zu einer Frage gehört. 
Wenn ein Benutzer einen Quiz-Versuch startet, wird für jede Frage eine 'AttemptQuestion'-Instanz erstellt, die mit der 
gewählten Antwort verknüpft wird. Dies ermöglicht die Speicherung der Ergebnisse des Versuchs. \newline

\noindent\textbf{'AttemptQuestion' Klasse:} Die 'AttemptQuestion'-Klasse repräsentiert eine Frage, die zu einem Quiz-Versuch gehört. 
Wenn ein Benutzer einen Quiz-Versuch startet, wird für jede Frage eine 'AttemptQuestion'-Instanz erstellt, die mit der gewählten 
Antwort verknüpft wird. Dies dient zur Erfassung und Speicherung der Ergebnisse des Versuchs. \newline

\noindent\textbf{'QuizAttempt' Klasse:} Die 'QuizAttempt'-Klasse repräsentiert einen Quiz-Versuch, den ein Benutzer starten kann. 
Ein Versuch kann mehrere 'AttemptQuestion'-Instanzen haben, die die Fragen des Versuchs repräsentieren. Zudem ist der 
Versuch mit dem Quiz verknüpft, das der Benutzer versucht hat. \newline

\subsubsection{Datenbank Modelle}

Die Datenbank-Modelle sind spezielle Datenmodelle, die ausschließlich im Kontext der Datenbankverwaltung in der Anwendung Verwendung finden.
In dieser Anwendung werden die Datenbank-Modelle über das Entity Framework automatisch aus den Backend-Modellen generiert. 
Diese Verfahrensweise nennt sich Code-First-Approach. \newline

\noindent Im Folgenden werden die Datenbank-Modelle näher erläutert und in einem Entity Relationship Diagramm (ERD) dargestellt:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/ERD-Diagramm.png}
  \caption{Entity Relationship Diagramm}
\end{figure}

\noindent In dem ERD-Diagramm ist zu erkennen, dass die Datenbank-Modelle eine ähnliche Struktur wie die Backend-Modelle aufweisen.
Dies ist darauf zurückzuführen, dass das Entity Framework die Datenbank-Modelle automatisch aus den Backend-Modellen generiert. 
Jedoch wurden die Properties, welche eigene Klassen darstellen in Tabellen umgewandelt und über 'Foreign Keys' verknüpft. \newline

\noindent Die Tabelle '\_EFMigrationHistory' in ERD-Diagramm wird vom Entity Framework automatisch generiert und dient zur Verwaltung der Migrationen.
Migrationen sind Änderungen an der Datenbankstruktur, die vom Entity Framework automatisch durchgeführt werden, wenn sich bei der Entwicklung
Backend-Models ändern. \newline

\noindent Die Tabelle 'AspNetUsers' im ERD-Diagramm wird vom ASP.NET Identity Framework automatisch generiert und dient zur Verwaltung der Benutzer.
Außerdem wurden die Tabellen 'AspNetUserClaims', 'AspNetUserLogins' und 'AspNetUserRoles' auch von ASP.NET Identity Framework generiert.

\subsubsection{API Modelle}

In .NET werden häufig sogenannte DTOs (Data Transfer Objects) 
zur Definition von API-Modellen verwendet. Diese DTOs können sich von den Datenbankmodellen 
unterscheiden und sind speziell an die Anforderungen der API angepasst. 
Die Verwendung von DTOs bietet eine Reihe von Vorteilen:

\begin{itemize}
  \item \textbf{Verschleierung der Datenbankstruktur:} Die Verwendung von DTOs ermöglicht die Verschleierung der Datenbankstruktur
   gegenüber externen Parteien. Dies geschieht, indem nur die DTOs nach außen sichtbar sind. Wenn die Kommunikation
  über interne Backend-Modelle erfolgen würde und diese direkt über das Entity Framework in die Datenbank gespiegelt würden, 
  könnte eine externe Partei die Datenbankstruktur rekonstruieren. Durch die Verwendung von DTOs bleibt die Datenbankstruktur geschützt.
  \item \textbf{Flexibilität \& Anpassbarkeit:} Die Verwendung von DTOs ermöglicht es, die API-Schnittstelle anzupassen, 
  ohne die Struktur des Projekts ändern zu müssen. Lediglich das Mapping zu den internen Modellen muss an die neuen Anforderungen 
  angepasst werden. Dies erleichtert die Aktualisierung der API, ohne dass umfangreiche Änderungen am gesamten Projekt vorgenommen 
  werden müssen.
  \item \textbf{Angepassbarkeit:} Durch die Verwendung von DTOs kann die API-Definition sehr präzise angepasst werden. 
  In vielen Fällen ist das Modell, das an das System gesendet wird, nicht identisch mit dem Modell, das das System zurückgibt. 
  Ein gutes Beispiel hierfür ist die Registrierung eines Benutzers. Bei der Registrierung wird ein Passwort an das System gesendet. 
  Wenn jedoch der Benutzer über die entsprechende Schnittstelle abgerufen wird, wird das Passwort nicht zurückgegeben. 
  Dies ermöglicht eine flexible Anpassung der API an die unterschiedlichen Anforderungen und Sicherheitsaspekte.
\end{itemize}

\subsection{Kommunikation zwischen Frontend und Backend}

Das Backend und das Frontend kommunizieren miteinander über das HTTP-Protokoll und nutzen 
eine API-Schnittstelle als Schnittstelle. Im Folgenden wird zunächst erläutert, wie diese 
Kommunikation funktioniert und wie die übertragenen Daten im Backend verarbeitet werden.

\subsubsection{Kommunikations Schnittstelle}

Die Kommunikation zwischen Backend und Frontend erfolgt über das HTTP-Protokoll. 
In diesem Kommunikationsablauf gehen die Anfragen stets vom Client zum Server. 
Der Server antwortet entsprechend auf die gestellten Anfragen.

Generell lassen sich vier verschiedene Arten von Anfragen unterscheiden. Diese Anfragetypen 
sind wie folgt:

\begin{itemize}
\item \textbf{GET-Requests:} Dieser Request-Typ wird verwendet um Daten abzurufen.
\item \textbf{POST-Request:} Dieser Request-Typ wird verwendet um neue Dinge anzulegen.
\item \textbf{PUT-Requests:} Dieser Request-Typ wird genutzt um Elemente upzudaten
\item \textbf{PATCH-Requests:} Dieser Request-Typ ersezt nur bestimmte Felder eines Elements.
\item \textbf{DELETE-Requests:} Diese Request-Typ wird verwendet um Elemente zu löschen.
\end{itemize}

\noindent Die Request-Methode steht im Header der HTTP-Anfrage und spielt eine entscheidende 
Rolle bei der Interaktion mit der API. Durch die Auswahl der richtigen Methoden ist es möglich, 
denselben API-Pfad für verschiedene Zwecke zu verwenden. Dies trägt zur Flexibilität und 
Effizienz bei, da unterschiedliche Anfragen mit denselben Endpunkten verarbeitet werden können.\newline

\noindent Der REST-Standard (Representational State Transfer) bietet klare Richtlinien für den 
Aufbau von API-Schnittstellen, die logisch und nachvollziehbar strukturiert sind. Dieser Standard 
legt nicht nur die Verwendung von Pfadmustern, sondern auch die Verwendung bestimmter 
Request-Typen fest. Bei der Entwicklung des Quiz-Projekts haben wir uns an diesen REST-Standard 
gehalten, um sicherzustellen, dass unsere API gut strukturiert ist. \newline

\noindent Die Beachtung des REST-Standards ist besonders wichtig in Bezug auf die Wartbarkeit 
unserer Anwendung. Eine klare und einheitliche API-Schnittstellendefinition erleichtert die 
Wartung und Aktualisierung der Anwendung erheblich. Darüber hinaus ermöglicht eine konsistente 
API-Schnittstelle anderen Entwicklern, verschiedene Oberflächen für unsere API zu erstellen, 
einschließlich mobiler Apps. Dies fördert die Interoperabilität und eröffnet neue Möglichkeiten 
für die Nutzung der Anwendung auf verschiedenen Plattformen. Die Einhaltung des REST-Standards 
trägt somit zur Erweiterbarkeit und Zugänglichkeit unserer Anwendung bei.


\subsubsection{API-Schnittstellen}

Die nachfolgende Abbildung zeigt die API-Endpunkte für den Authentifizierungs-Endpoint und den Quiz-Endpoint.

\noindent Bei dem Quiz-Endpoint

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/Auth_Quiz-Endpoint.png}
  \caption{Auth \& Quiz API Endpoint Definition}
\end{figure}

\noindent Im Authentifizierungs-Endpoint gibt es zwei Routen. Die erste Route dient dem 
Login-Prozess, bei dem Benutzer ihre Anmeldeinformationen übermitteln können. Wenn die 
eingegebenen Daten korrekt sind, wird als Antwort ein JWT-Token (JSON Web Token) ausgegeben. 
Dieser Token ermöglicht den Zugriff auf die geschützten API-Endpunkte. Bei jeder Anfrage an 
diese geschützten Endpunkte wird der Token im HTTP-Header mitgesendet, um die Authentizität des 
Benutzers zu gewährleisten. \newline

\noindent Die zweite Route ist der Registrierungs-Endpoint, der es Benutzern ermöglicht, 
sich in der Anwendung zu registrieren. Für die Registrierung sind ein Benutzername, eine 
E-Mail-Adresse und ein Passwort erforderlich. Nach erfolgreicher Registrierung wird eine 
entsprechende Bestätigung als Antwort zurückgegeben. Anschließend können sich Benutzer mit den 
zuvor gewählten Anmeldeinformationen am Login-Endpoint anmelden, und ihnen wird ein gültiger 
Authentifizierungstoken zur Verfügung gestellt. \newline

\warningbox{Bevor das System in den Produktivbetrieb übergeht, ist es empfehlenswert,
eine Validierung der E-Mail-Adressen zu implementieren, um Spam-Registrierungen zu verhindern.
In dieser prototypischen Umsetzung wurde bewusst auf diese Validierung verzichtet. 
Diese Validierung der E-Mail-Adresse kann auch mit ASP.NET IdentityUser implementiert werden.}

\noindent Die folgenden Abbildung stellt die API-Endpunkte für den Quiz-Attempt-Endpoint und den 
Quiz-Question-Endpoint dar. Auf diese wird nachfolgend näher eingegangen.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/QuizAttempt_QuizQuestion-Endpoint.png}
  \caption{Quiz Attempt \& Quiz Question Endpoint Definition}
\end{figure}

\noindent Die ersten beiden Anfragen im Quiz-Attempt-Endpoint dienen der Erstellung und 
dem Abruf von Quiz-Versuchen für den angefragten Benutzer. Wenn ein Quiz-Versuch erstellt 
wird, wird dieser auch dem aktuell angemeldeten Benutzer zugeordnet, der über den 
Authentifizierungstoken identifiziert werden kann. \newline

\noindent Die dritte Anfrage ermöglicht den Abruf eines spezifischen Versuchs anhand seiner eindeutigen ID,
während die vierte Anfrage alle Quiz-Versuche eines Teams zurückgibt. Die fünfte Anfrage liefert alle 
Quiz-Versuche eines bestimmten Quizzes. \newline

\noindent Der letzte Request dient der Aktualisierung eines Quiz-Versuchs, was dann erforderlich ist,
 wenn ein Benutzer das Quiz tatsächlich durchführt und Änderungen am Versuch erforderlich sind. \newline

 \noindent Die Quiz-Question-Endpoints enthalten klassischerweise die CRUD-Operationen
(Create, Read, Update, Delete) für Fragen. Die erste Anfrage ermöglicht den Abruf aller Fragen, die zu einem 
bestimmten Quiz gehören. Die zweite Anfrage dient der Erstellung einer neuen Frage. Die dritte Anfrage 
erlaubt den gezielten Abruf einer Frage anhand ihrer eindeutigen ID. Die vierte Anfrage ermöglicht die 
Aktualisierung einer vorhandenen Frage. Die fünfte Anfrage schließlich gestattet die Löschung einer Frage.\newline

\noindent In der folgenden Abbildung werden die API-Endpunkte für den Team-Endpoint und der Score-Endpoint dargestellt.
Auf diese Endpunkte wird nachfolgend näher eingegangen.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/Score_Team-Endpoint.png}
  \caption{User \& Score API Endpoint Definition}
\end{figure}

\noindent Die Team-Endpoints enthalten klassischerweise die CRUD-Operationen (Create, Read, Update, Delete) für Teams. 
In dieser Dokumentation werden wir nicht näher auf diese Operationen eingehen. Der letzte Endpoint in der Gruppe der Team-Endpoints 
dient dem Abruf des Team-Scores. Dieser Score wird in der Benutzeroberfläche im Team-Dashboard angezeigt. \newline

\noindent Die Score-Endpoints bieten Endpunkte zur Berechnung der Punktzahlen für Quizze und Benutzer. 
Darüber hinaus ermöglichen sie den Abruf von Team- und Benutzer-Leaderboards. \newline

\noindent Die nachfolgend Abbildung zeigt die API-Endpunkte für den User-Endpoint, den Team-User-Endpoint und den Health-Endpoint.
Diese werden nachfolgend erläutert.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/TeamUser_User-Endpoint.png}
  \caption{Team \& Team-User API Endpoint Definition}
\end{figure}

\noindent Die Team-User Endpoints werden verwendet um User einem Team hinzuzufügen oder zu entfernen. 
Außerdem können alle User eines Teams abgerufen werden. \newline

\noindent Die User-Endpoints enthält nur einen Endpoint, der den aktuellen User zurückgibt. \newline

\noindent Der Health-Endpoint dient der Überprüfung der Erreichbarkeit des Backends und kann 
vom einem Monitoring System aufgerufen werden.

\subsubsection{Datenflow im Backend}

In einer ASP.NET API-Anwendung wird jede Anfrage an einen API-Endpunkt von einem sogenannten 
Controller verarbeitet. Die Definition des Controllers ist entscheidend für die Verarbeitung 
der Anfrage und die Festlegung der API-Route. Bevor jedoch eine Anfrage den Controller erreicht, 
werden bestimmte Prüfungen von sogenannter Middleware durchgeführt. \newline

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/API-Sequence-Diagramm.png}
  \caption{Sequence Diagramm for API Request}
\end{figure}

\noindent Die Middleware ist eine Komponente, die in der Verarbeitungspipeline zwischen verschiedenen 
Aufgaben agiert. Wie in der Abbildung ersichtlich, wird zunächst eine Anfrage vom Client an den Server 
gesendet. Am Server wird die Anfrage validiert, insbesondere in Bezug auf das enthaltene Datenmodell,
den Request-Body und die Request-Header.Im nächsten Schritt erfolgt die Umwandlung des Requests mit 
JSON-Daten in ein C\# Objekt, um die Verarbeitung im Controller zu ermöglichen. Anschließend erfolgt eine 
optionale Authentifizierung, die überprüft, ob die Anfrage von einem authentifizierten Benutzer stammt.
Erst nach erfolgreicher Authentifizierung erreicht die Anfrage den Controller und kann von diesem verarbeitet 
werden. \newline

\noindent Bei der Strukturierung eines ASP.NET API-Projekts gibt es verschiedene Ansätze zur Organisation der 
Verarbeitung von Anfragen. In diesem Projekt wurde die Entscheidung getroffen, dass der Controller für d
as Mapping der eingehenden DTO-Objekte auf die Backend-Modelle und die Autorisierungsvalidierung 
verantwortlich ist. Die eigentliche Verarbeitung der Anfrage erfolgt in sogenannten Services.

\noindent Ein Service ist eine Klasse, die eine spezifische Aufgabe erfüllt. In diesem Projekt sind 
Services für verschiedene Objekte implementiert. Im Service wird ausschließlich mit den Backend-Modellen 
gearbeitet, und der Zugriff auf die Datenbank erfolgt nur dort.

\noindent Im Service findet die tatsächliche Verarbeitung der Anfrage statt, einschließlich der Rückgabe der Daten.
